<h1>Using Exceptions</h1>

<h2>Exceptions vs. Errors</h2>
<p>
Exceptions are a language mechanism that helps transfer control from one point
in the program to another without cluttering the code in between. As always, we
should keep a clear distinction between the <i>mechanisms</i> the programming
language designers chose to put at our disposal and the proper ways to use those
mechanisms to write good code.</p>
<p>
In particular, an exception should not be thought of as exactly the same thing
as an error, although exceptions are often used to indicate errors. We will use
the word “error” to mean a mistake in the code: a <i>programmer</i> error. One
reason why the ideas of exceptions and errors are confused is that exceptions
are a useful way to stop programs quickly and cleanly when a programmer error
is detected.
</p>
<p>
Exceptions have another use, however.  We may in some cases want to use
exceptions to handle unusual conditions within the code. These might be
“errors” in (that is, misconfigurations of) the environment in which the
program is being run rather than mistakes by the programmer. We want the program
to be able to handle such unusual conditions and respond accordingly;
exceptions are a nice way to handle such unusual conditions fairly cleanly.
Without exceptions, the code to handle unusual conditions ends up mixed in
with the code that handles normal-case execution of the program. This
mixing makes the normal-case code (and hence the code as a whole) harder
to understand. With exceptions we can factor out separately the code
that handles unusual conditions.
</p>
<p>
Exceptions are generated either by using the <code>throw</code> statement to
throw an object of a subclass of class <code>Throwable</code>, or by using a
built-in operation that generates an exception under some condition.  Java has
a quite a few builtin exceptions that can be generated by standard language
constructs. Null values generate a <code>NullPointerException</code> if used as
objects, arrays generate an <code>ArrayIndexOutOfBoundsException</code> if the
array index is, well, out of bounds, and so on.
</p>
<p>
Exceptions can also be <em>caught</em> by using a <code>try-catch</code>
statement. It has a body defining what code is allowed to
generate an exception, then at least one <code>catch</code> clause (and possibly
a <code>finally</code> clause). The <code>catch</code> clauses define which
exceptions generated by the <code>try</code> body will be caught and define
what code is run when the exception is caught. The <code>finally</code> block
provides some code that is always run before the <code>try</code> statement
finishes, whether or not an exception was generated.
The <code>finally</code> block is very useful for performing cleanup
work that must happen regardless of how cleanly the <code>try</code> statement
completes. For example, it might close files that were opened in the main body
of the <code>try</code>.
</p>
<p>
Here is a small example of using exceptions to separate handling of unusual conditions
from normal-case code. This code parses the command line of the program by scanning
the argument list from left to right. However, it needs to handle the case in which
the user fails to provide a filename to the <tt>--file</tt> command-line option.
The code can be simpler if it doesn't have to check
that every index into the array of arguments is in bounds.
As the code below demonstrates, it is possible to use <code>try...catch</code> to
factor out the handling of that problem in an exception handler:
</p>
<pre class="load">
<a href="03except_invar/arglist.java">arglist.java</a>
</pre>
<p>
In a typical command-line parser, there will be multiple option for which a user
might forget to supply the corresponding argument. Code in the style above not
only avoids cluttering up the normal-case code with error handling, but it even
consolidates the handling of multiple errors into one place.
</p>

<h3>How not to handle unusual conditions</h3>
<p>An alternative to using exceptions is to define
special return values to indicate unusual conditions. The Java libraries often
(unfortunately) follow this strategy. For example, the specification for
<code>String.indexOf</code> looks like this:
</p>
<pre>
/**
 * Returns: if the string argument occurs as a substring within this
 *          object, then the index of the first character of the first
 *          such substring is returned; if it does not occur as a
 *          substring, -1 is returned.
 */
public int indexOf(String str)
</pre>
<p>The problem with the special-return-value strategy is that it's easy to
forget to check for the special value, writing code such as this:
</p>
<pre>
    String s1 = s2.substring(s2.indexOf("header:") + 7);
</pre>
<p>If the string doesn't begin with <tt>header:</tt>, we'll get a result that
includes the 6th and following characters of <code>s2</code>. This
doesn't make much sense! If the library designers had instead chosen to 
throw an exception, client code could look like that above, and the compiler
would force clients to remember to check for the case in which &ldquo;<tt>header:</tt>&rdquo;
isn't found.
</p>
<h3>Checked vs unchecked exceptions</h3>
<p>
Java requires that some exceptions be declared in methods that might
generate them.  These are called <em>checked exceptions</em>. Checked
exceptions force the client to be aware that they might happen
and to handle them appropriately. This helps lead to more robust
code. Unchecked exceptions include the <em>run-time exceptions</em>
like <code>NullPointerException</code> but also subclasses of
<code>Error</code>. The compiler will not warn clients if they are
ignoring unchecked exceptions.
</p>
<p>
When should you use each kind of exception? It depends on why the exception is being
used:
</p>
<ul><li>
<p>
If the exception is thrown because there is a programmer error, unchecked exceptions
are the right choice. Particularly, <code>Error</code> or a subclass (e.g., 
<code>AssertionError</code>) should be used.
</p></li>
<li><p>
If the exception is thrown because there is an unusual condition, a checked exception
should be used. The client should be aware that the condition can happen.
Sometimes checked exceptions can be annoying because the programmer &ldquo;knows&rdquo;
they cannot happen, yet they must be declared. The simplest way to deal with this is
to write a catch clause for those exceptions, and throw an <code>Error</code> from
the handler.
</p></li>
</ul>

<h3>Specifying partial functions</h3>
<p>
The <code>coefficient</code> method is an interesting case, because it is a
<b>partial function</b> that has no natural result in the case where the
requested exponent is negative. There are several alternative ways to deal with
this situation, with varying tradeoffs in terms of performance vs. debugging.
The alternative least friendly to the client is simply to require that the
requested exponent be nonnegative, by giving a requires clause:
</p>

<pre>
/** Returns: the coefficient of the polynomial term with exponent n, or zero
 *           if there is no such term.
 *  Requires: n ≥ 0
 */
double coefficient(int n);
</pre>

<p>
What happens if the client calls <tt>coefficient(-1)</tt>? This spec
doesn't say. Maybe it throws an exception, maybe it goes into
an infinite loop, maybe it just returns a wrong answer. If the client makes
this call, the code can do anything it likes. But that is okay. The spec
is clear that the client must ensure that <tt>n</tt> is not negative.
If the requires clause is violated, it is the <em>client's</em> fault.
</p>

<p>A more forgiving version of the same spec uses a <b>checks clause</b>, which is
a kind of requires clause. The difference is that the checks clause promises to check that the
precondition holds, and to stop the program as cleanly as possible if it is
violated. For example, the method might throw an exception that is a subclass of
<b>Error</b>, which the client should not try to catch. However, client code
that violates the precondition is still wrong code.  It is still the
client's fault if the precondition is violated.
</p>

<pre>
/** Returns: the coefficient of the polynomial term with exponent n, or zero
 *           if there is no such term.
 *  Checks: n ≥ 0
 */
double coefficient(int n);
</pre>

<p>A good way to implement checks clauses is by using the <code>assert</code>
statement. For example, the implementation of <code>coefficient</code> might
check this precondition as follows:</p>

<pre>
double coefficient(int n) {
    assert n >= 0;
    ...
}
</pre>

<p>The <code>assert</code> statement may check any boolean condition. If Java
is used with assertions enabled (by using the <tt>-ea</tt> option, which you
<em>should</em> enable in your development environment), then the boolean condition is tested at run
time. If it evaluates to <code>true</code>, nothing happens. If it executes to
<code>false</code>, an error <code>AssertionError</code> is generated
and will halt the program at the point where the assertion failed.</p>

<p>It is also even more helpful when writing a checks clause to tell the programmer
what exception will be thrown when the check fails, e.g.</p>
<pre>//  Checks: n ≥ 0 (assert)</pre>
<p class="cont">or:</p>
<pre>//  Checks: n ≥ 0 (throws NegException)</pre>
<p>This may help when debugging. However, if an exception is thrown to indicate
an error, the client (caller) should <em>not</em> catch that exception. The exception
indicates a problem in the client code that should not just be papered over.
</p>

<p>A third way to deal with partial functions is to make them total, so
that the customer is never wrong:</p>
<pre>
/** Returns: the coefficient of the polynomial term with exponent n, or zero
 *           if there is no such term. Throws NegException if n is negative.
 */
double coefficient(int n) throws NegException;
</pre>
<p>
Notice that now the information about the thrown exception is part
of the returns clause, and appears in the signature, indicating that
this exception is expected behavior in some situations and that
the client had better be ready to handle it when it happens. The client
can call with any arguments it likes, but the price to pay is writing
code to handel the exception. The
<em>implementation</em> of <code>coefficient</code> might be exactly
the same as when we used a &ldquo;checks&rdquo; clause. But with the
checks clause, the contract says that the client is in error; with
exceptions appearing in the returns clause, the client is always
&ldquo;right&rdquo;.
</p>

<h3>Javadoc and exceptions</h3>
<p>
Javadoc doesn't completely support the clauses we have been describing
thus far, though it has been evolving in that general direction.  If
you want to use Javadoc to generate HTML documentation, you will need
to adapt this documentation strategy accordingly. The key is not that
you need to have explicitly labeled clauses that Javadoc understands,
but that you should know for each thing you write in the comment which
clause it belongs to, and include all the information that should be
found in the clauses that the spec of your code needs.
</p>
