<h1>User interface design</h1>

<h2>High-level goal: Usability</h2>

<p>
A good user interface (UI) enables users to get their job done efficiently,
easily, and enjoyably. User interface design focuses on users and their
experience of using the system.
</p>
<p>
Some of the principles that normally apply to software engineering
tasks are less central to user interface design.  In particular,
we have been focusing on the needs of programmers, but for UI
design, we worry about users and how they interact with the system. Our
focus is therefore not on making the programmer's job easy, although we
of course still care about how to deliver a good user interface in
a cost-effective way.
</p>
<p>
We might think that a good user interface is one that provides the 
largest feature set possible. Sometimes a large feature set is needed,
but often it is not what the user needs.
</p>
<p>
We now take a look at the problem of UI design and try to elucidate some
principles that can guide us when designing and implementing user interfaces.
</p>

<h2>Know your users. Design to them.</h2>

<blockquote>
<i>
“If there is any one secret of success, it lies in
the ability to get the other person’s point of
view and see things from that person’s angle as
well as from your own”</i> — Henry Ford (actually)
</blockquote>

<p>
  The most critical aspect of designing any interface is to understand how
  it will be used, which means understanding your users.
</p>
<p>
  Different applications have different kinds of users. Some users may use the
  software frequently and be familiar with it, whereas other software may only
  be used occasionally by its users.  Users may be novices to the application
  domain, or they may be knowledgeable about it.  Users may receive training in
  the use of the system, or they may need to use it without training. Different
  kinds of users need different kinds of UI designs.
</p>
<p>
    We might think that the way to design a good user interface is to give
    users what they say they want. But users are not typically good user
    interface designers, so treating their ideas as prescriptions often leads
    to bad designs.  As the (unfortunately apocryphal) quote often attributed to Henry
    Ford says, “If I had asked people what they wanted, they would have said
    faster horses.”
</p>
<p>
    While we don't want users to dictate the design, it is still crucial
    to understand your users and the tasks they want to accomplish.
    Interviewing potential users is an important early step in design.
    Focus on understanding the tasks they want to carry out rather than
    on what specific features they are asking for. Then you can design
    while being conscious of how the user experience meshes with the
    intended uses.
</p>
<p>
    A common error when designing user interfaces is to think that the user
    thinks like you do. Most users are <i>not</i> like you. To combat
    this form of bias, it is critical to interview users and to test your designs 
    with them.
</p>

<h3>Infrequent/new users</h3>
<p>
For users who use the software too infrequently to remember it, or who are
encountering it for the first time,  the design emphasis should be on providing
an interface that is as unsurprising and familiar as possible, with a
a gentle learning curve.
</p>

<ul>
    <li> <b>Discoverability</b>: users should be able to learn the features and interactions
     of the application on their own. Menus are the classic way to make
     features discoverable, by making all functionality hierarchical and explorable.
    <li> <b>No Loaded Guns.</b>. The interface should protect the user against
      damaging actions that might surprise a novice user trying to use it. For an
      amusing demonstration of this principle, watch Andy Aaron's classic Saturday Night Live skit,
        <a href="https://www.youtube.com/watch?v=GYeYJ0r5D2Q">“Blowing up a Building”</a>.
    <li> <b>Principle of Least Surprise.</b> This principle applies to any interface design,
        including user interface design.
    <li> <b>Visual Clarity.</b> The novice user will be overwhelmed by complex displays of information.
        Stick to simple, clear displays that are easy to read and to parse visually.
    <li> <b>Consistency.</b> The user interface design should be internally consistent but also consistent
        with the design of other applications that the user is likely to be familiar with. Consistency
        will make the interface easier to pick up and use successfully.
    <li> <b>Metaphors.</b> To help users quickly understand an interface while avoiding textual explanations,
        metaphors like icons can be very helpful. For example, a trash can image will be easily understood as
        supporting deletion functionality.
    <li> <b>Sensory cues.</b> To communicate more effectively with the user, use multiple kinds of
        cues, including visual cues like shape and color, sound cues, and even haptic feedback such as
        vibration. Reinforce important information through multiple sensory cues.
</ul>

<h3>Intermittent but knowledgeable users</h3>
<p>
Here the focus is on making features discoverable, and reducing the
memory burden for users. The user has an idea what features are available
but may not remember how to access them.
</p>
<ul>
    <li>Internally consistent appearance and actions
    <li>Clear visual structure
    <li>Protection from dangerous action for safe exploration
</ul>

<h3>Frequent/power users</h3>

<p>
For users expected to have a lot of experience with the application,
and perhaps also training, the design emphasis should be on 
efficient interactions.
</p>

    <ul>
        <li> Usable ≠ "User friendly"
        <li> Powerful actions, short interaction sequences
        <li> Rapid response times
        <li> Rich controls, shortcuts for common actions
        <li> Exploit muscle memory
        <li> Information-rich displays
        <li> Customization and macros
        </ul>
    </ul>


<h2>UI as dialogue</h2>

    <li> App needs to be good conversation partner
        <ul>
        <li> Ratify actions quickly
        <li> Be responsive (e.g., highlighting)
        <li> Show progress on longer actions
        </ul>
    <li> Work out the conversations
	<ul>
            <li> Use a set of <b>use cases</b> to figure out what users will
                have to do.
            <li> Eliminate unnecessary user actions.
            <li> Aim for short interactions with clear progress:
                <b>intermediate goal satisfaction</b> (cf. DisneyWorld ride lines)
            <li> Use testing to find your blind spots (as developer).
	    <li> May need to write testing scripts for human testers. Key
		(as usual): coverage.
	</ul>

    <li> Choosing the right interaction paradigm: direct manipulation vs. I/O vs. ?
    <ul>
    <li> Goal: app feels like extension of user, promotes flow
    <li> Example: driving a car vs. programming/remote-controlling a car, or Word vs. TeX.
    <li> UI abstracts underlying application state (the model)
    <li> Abstraction does <em>not</em> need to match the implementation
    <li> Good implementation strategy: Model != View != Controller
    <li> Good abstraction: Model = View = Controller
    <li> Less direct styles:
        <ul>
            <li>Menu selection/hierarchical navigation
            <li>Form fill-in + submit
            <li>Command languages
        </ul>
    </ul>

    <li>GUI helps by <em>restricting the vocabulary</em>
        <ul>
        <li> Channels `utterances´ (user actions) into meaningful directions
        <li> Reduces memorization
        </ul>

    <li>Use modes well
        <ul>
            <li> Modes: states of UI that restrict interactions.
            <li> Modes help with restricted context-sensitive vocabulary
            <li> Avoid overusing modes and trapping users in modes.
        </ul>
    <li>Interaction time scales</li>
        <ul>
        <li> &lt;1/60 s: biologically imperceptible: faster than neurons
        <li> &lt;1/30 s: fast enough for continuous-feedback tasks (e.g., mouse tracking)
        <li> &lt;1/10 s: imperceptible delay for discrete actions, e.g. button clicks.
        <li> &lt;1/2 s: fast but noticeable (ok for command-response interaction)
        <li> 1/2 s to 5 s: increasingly annoying but user stays focused
        <li> 5 s to 10 s: User starts to lose attention.
        <li> 10 s to 1 min: User becomes distracted and
        productivity declines. App needs to support parallel activities.
        <li> &gt;1 min: Significant loss of productivity.  User leaves for coffee.
        </ul>


<h2>Learning and memory</h2>
<li>
Goal: interface that users can learn to use sufficiently quickly
and can remember how to use.

    <ul>
    <li> Obvious controls
        <ul>
        <li> Easy to find and identify
        <li> Don't set up user for a fall: disable invalid/dangerous actions
        </ul>

    <li> Avoid overload
        <ul>
        <li> Human can only hold 7 things in their head at once
        <li> Avoid long menus, lots of buttons
        <li> Design visuals carefully for rapid comprehension
        </ul>
    </ul>

    <li> Context-sensitive help
        <ul>
        <li> Task-focused rather than feature-focused (unlike most modern apps!)
        </ul>

    <li> Exploit spatial memory
	<ul>
        <li> Tap into humans ability remember to things spatially: e.g., the
                <b>memory palace</b>.

        <li> Each window or dialogue is a place you can go&mdash;make it a
             place user wants to be in.
	<li> Avoid unnecessary places to learn about and navigate between.
	<li> Make navigation simple, clear, easy.
	<li> Big-picture overviews help users stay oriented
	    <ul>
	    <li> bird's eye views
	    <li> menus with highlights
	    </ul>
	</ul>

    <li> Exploit motor memory (esp. for power users)
	<ul>
	<li> Frequent users remember UI in their muscles.
	<li> Make actions to get an effect consistent so motor memory
	      can carry users through without thinking.
	</ul>

    </ul>

<h2>Visual design</h2>

    <ul>
    <li> Avoid visual clutter
    <ul>
        <li> Use space shading, color rather than lines to organize
             information.
	<li> Use low-contrast separators
	<li> Maximize &ldquo;information/ink ratio&rdquo; (Tufte)
    </ul>
    <li> Aim for visual consistency
	<ul>
	<li> Large apps need a written <em>style guide</em> to keep look and feel
	      consistent as app evolves.
	<li> E.g., buttons that change state vs. buttons that navigate
	      vs. buttons that expose hidden information: user should
	      be able to distinguish.
	</ul>
    <li> Employ visual features as an <i>additional</i> communication channel.
        <ul>
        <li> Shape (up to 15)
        <li> Color (up to 24)
        <li> Size, length, thickness: up to 6.
        <li> Orientation: up to 24
        <li> Texture
	<li> Differing perceptual capabilities of some users (esp.
            for color) ⇒ cannot rely solely on visual features to
                communicate, but they can complement the information that
	      is there in another form.
        </ul>
    </ul>
<h2>Useful reading</h2>
<ul>
  <li>Envisioning Information. Edward Tufte.</li>
  <li>Principles of Computer Graphics. Foley and Van Dam. Ch 8.2-8.3, 9</li>
  <li>About Face 2.0, Cooper and Reimann. </li>
  <li>Human–Computer Interaction. Dix, Finlay, Abowd, Beale.</li>
  <li>The UX Book. Hartson and Pyla.</li>
</ul>
