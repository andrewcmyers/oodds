<h1>Exceptions</h1>

<p>Exceptions are an important language mechanism for dealing with unexpected or
unusual conditions that arise during the execution of a program.  How programming
languages should support exceptions is still a subject of debate, but using
exceptions well can make programs clearer and more reliable.

</p>

<h2>The Java exception mechanism</h2>
<p>
In general, a statement or expression may not evaluate in a normal way. For example,
if we try to divide a number by zero, there is no sensible result. Java handles such
operations using <em class=term>exceptions</em>.
</p>
<p>
An exception is associated with a particular Java class, which must be a subclass
of the class <code>Throwable</code>. When an exception is generated, it is associated
with an object of such a class. For example, dividing by zero results in a newly
created object of the class <code>java.lang.ArithmeticException</code>.
</p>
<p>
Exceptions are generated either by using the <code>throw</code> statement to
explicitly generate an exception, throwing an object of a suitable class, or by
using a built-in operation that generates an exception under some condition.
In Java, quite a few built-in exceptions can be generated by standard language
constructs. For example, null values generate a
<code>NullPointerException</code> if used as objects, arrays generate an
<code>ArrayIndexOutOfBoundsException</code> if the array index is out of
bounds, and so on.
</p>
<p>
Exceptions can also be <em>caught</em> by using a <code>try-catch</code>
statement. It has a body defining what code is allowed to
generate an exception, then at least one <code>catch</code> clause.
The <code>catch</code> clauses define which
exceptions generated by the <code>try</code> body will be caught and define
what code is run when the exception is caught. A catch clause names the class
of exceptions that it handles; any subclass of the named class will be caught.
</p>
<p>
If an exception is generated in a method that does not catch it, the method
terminates and the exception propagates to its caller. Therefore, when an
exception is generated, it propagates up the call stack until it either reaches
a matching <code>catch</code> clause, or the program terminates because of an
unhandled exception.
</p>
<p>
A <code>try–catch</code> statement can also have a <code>finally</code> block, which
provides some code that is always run before the <code>try</code> statement
finishes, whether or not an exception was generated.
The <code>finally</code> block is very useful for performing cleanup
work that must happen regardless of how cleanly the <code>try</code> statement
completes. For example, it might close files that were opened in the main body
of the <code>try</code>. Java also has a
<a href='#try%2dwith%2dresources'>
try-with-resources statement</a> for this
purpose.
</p>
<h3>Example: catching exceptions</h3>
<p>
Here is a small example of catching exceptions.
This code parses the command line of the program by scanning
the argument list from left to right. It looks for a <kbd>--file</kbd> option
that specifies a file name, but it needs to handle the case in which
the user fails to provide a filename.
The code can be simpler if it doesn't have to check
that every index into the array of arguments is in bounds.
As the code below demonstrates, it is possible to use <code>try...catch</code> to
factor out the handling of that problem into an exception handler:
</p>
<pre class="load">
<a href="arglist.java">arglist.java</a>
</pre>
<p>
A command-line parser would commonly have multiple options for which a user
might forget to supply the corresponding argument. Code in the style above not
only avoids cluttering up the normal-case code with error handling, but also
consolidates the handling of multiple errors into one place.
</p>
<h3>Checked vs. unchecked exceptions</h3>
<p>
Java requires that some exceptions be declared in methods that might
generate them.  These are called <em class=term>checked exceptions</em>. Checked
exceptions force the client to be aware that they might happen
and to handle them appropriately.
If a method contains an expression or statement that can generate a checked exception,
the method must either handle the exception or declare that it can throw the
exception.  Declaring exceptions helps make code more reliable because clients
can tell what exceptions will be generated, and the compiler will identify when
these exceptions are not handled.
</p>
Unchecked exceptions include the <em class=term>run-time exceptions</em>
like <code>NullPointerException</code> but also subclasses of
<code>Error</code>. The compiler will not warn clients if they are
ignoring unchecked exceptions.
</p>
<p>Exception classes that are subclasses of the class <code>Exception</code>
(itself a subclass of <code>Throwable</code>) are checked exceptions, unless
they are also subclasses of <code>RuntimeException</code>. Java programmers
are free to define their own new subclasses of <code>Exception</code> that they
can then use in their code. For example, if we wanted to define a square root
function, we could define a new checked exception named <code>Negative</code>.
Any code that called <code>sqrt</code> would then have to handle the case where
the argument is negative.
</p>
<pre>
class Negative extends Exception {}

/** Returns: the square root of x.
    Throws Negative if x < 0 */
double sqrt(double x) throws Negative { ... }
</pre>

<p>Using code can handle the exception either with <code>try–catch</code> or by
passing the exception up the stack where a caller will have to handle it.
These two options are sketched in the code below:
</p>

<pre class="codeleft">
void f() {
    try {
        ...
        double z = sqrt(x) + sqrt(y);
        ...
    } catch (Negative exc) {
        err.println("Out of bounds");
    }
}
</pre>
<pre class="coderight">
void f() throws Negative {
    ...
    double z = sqrt(x) + sqrt(y);
    ...
}
</pre>

<h2>Exceptions vs. Errors</h2>
<p>
Exceptions allow the programmer to transfer control from one point in the
program to another—from the <code>throw</code> to the <code>catch</code>—without cluttering the code in between. As always, we should
keep a clear distinction between the <i>mechanisms</i> the programming language
designers chose to put at our disposal and the proper ways to use those
mechanisms to write good code.</p>
<p>
In particular, an exception should not be thought of as exactly the same thing
as an error, although exceptions are often used to indicate errors. We will use
the word “error” to mean a mistake in the code: a <i>programmer</i> error. One
reason why the ideas of exceptions and errors are confused is that exceptions
are a useful way to stop programs quickly and cleanly when a programmer error
is detected.
</p>
<p>
Exceptions have another use, however.  We may in some cases want to use
exceptions to handle unusual conditions within the code. These might be
“errors” in (that is, misconfigurations of) the environment in which the
program is being run rather than mistakes by the programmer. We want the program
to be able to handle such unusual conditions and respond accordingly;
exceptions are a nice way to handle such unusual conditions fairly cleanly.
Without exceptions, the code to handle unusual conditions ends up mixed in
with the code that handles normal-case execution of the program. This
mixing makes the normal-case code (and hence the code as a whole) harder
to understand. With exceptions we can factor out separately the code
that handles unusual conditions.
</p>

<h3>How not to handle unusual conditions</h3>
<p>An alternative to using exceptions is to define
special return values to indicate unusual conditions. The Java libraries often
(unfortunately) follow this strategy. For example, the specification for
<code>String.indexOf</code> looks like this:
</p>
<pre>
/**
 * Returns: if the string argument occurs as a substring within this
 *          object, then the index of the first character of the first
 *          such substring is returned; if it does not occur as a
 *          substring, -1 is returned.
 */
public int indexOf(String str)
</pre>
<p>The problem with the special-return-value strategy is that it's easy to
forget to check for the special value, writing code such as this:
</p>
<pre>
    String s1 = s2.substring(s2.indexOf("header:") + 7);
</pre>
<p> This code is intended to extract a substring containing the value of a header.
But if the string <em>doesn't</em> begin with the expected substring &ldquo;<tt>header:</tt>&rdquo;, the result
is the 6th and following characters of <code>s2</code>, starting from the colon character.
This result doesn't make much sense! If the library designers had instead chosen to 
throw an exception, client code could look exactly the same, but the compiler
would force clients to remember to check for the case in which &ldquo;<tt>header:</tt>&rdquo;
is not found.
</p>
<p>
Another example of a function with a special return value is
the standard Java function for computing the square root of a
number, <code>Math.sqrt</code>.
The return value <code>NaN</code> (“Not A Number”) is returned
when the argument is negative. If the programmer is not careful, <code>NaN</code>s can
propagate through a series of calculations, turning the final result into
garbage—a dangerous approach if the calculations are used to control
real-world systems like airplanes or spacecraft.
</p>

<h3>Checked or unchecked?</h3>
<p>
Given that some exceptions are checked and other unchecked, it may not be clear what
sort of exception to use. Understanding the purpose of exception helps us make
this choice. It depends on why the exception is being used.
</p>
<ul><li>
<p>
If the exception is thrown because there is a programmer error, unchecked exceptions
are the right choice. Particularly, <code>Error</code> or a subclass (e.g., 
<code>AssertionError</code>) should be used.
</p></li>
<li><p>
If the exception is thrown because there is an unusual condition, a checked
exception should be used. This is an anticipated behavior, so the client should
be aware that the condition can happen.  Sometimes checked exceptions can be
annoying because the programmer &ldquo;knows&rdquo; they cannot happen, yet
they must be declared to satisfy the compiler. The simplest and safest way to
deal with this problem is to write a catch clause for those exceptions, and to throw an
<code>Error</code> from the handler.  </p></li>
</ul>

<h3>Specifying partial functions</h3>
<p>
Recall the <code>sqrt</code> method. It is a
<em class=term>partial function</em> that has no natural result in the case where the
requested exponent is negative. There are several alternative ways to deal with
this situation, with varying tradeoffs in terms of performance vs. debugging.
The alternative least friendly to the client is simply to require that the
requested exponent be nonnegative, by giving a requires clause:
</p>

<pre>
/** Returns: the square root of x
 *  Requires: x ≥ 0
 */
double sqrt(double x) {
    ...
}
</pre>

<p>
What happens if the client calls <tt>sqrt(-1)</tt>? This spec
doesn't say. Maybe it throws an exception, maybe it goes into
an infinite loop, maybe it just returns a wrong answer. If the client makes
this call, the code can do anything it likes. But that is okay. The spec
is clear that the client must ensure that <code>n</code> is not negative.
If the requires clause is violated, it is the <em>client's</em> fault.
</p>

<p>A more forgiving version of the same spec uses a <em class=term>checks clause</em>, which is
another way to express a precondition. The difference is that the checks clause promises to check that the
precondition holds, and to stop the program as cleanly as possible if it is
violated. For example, the method might throw an exception that is a subclass of
<code>Error</code>, which the client should not try to catch. However, client code
that violates the precondition is still wrong code.  It is still the
client's fault if the precondition is violated.
</p>
<p>A good way to implement checks-clauses is by using the <code>assert</code>
statement. For example, the implementation of <code>coefficient</code> might
check this precondition as follows:</p>

<pre>
/** Returns: the square root of x
 *  Checks: x ≥ 0
 */
double sqrt(double x) {
    assert x >= 0;
    ...
}
</pre>

<p>The <code>assert</code> statement may check any boolean condition. If Java
is used with assertions enabled (by using the <tt>-ea</tt> option, which you
<em>should</em> enable in your development environment), then the boolean condition is tested at run
time. If it evaluates to <code>true</code>, nothing happens. If it executes to
<code>false</code>, an error <code>AssertionError</code> is generated
and will halt the program at the point where the assertion failed.</p>

<p>It is also even more helpful when writing a checks clause to tell the programmer
what exception will be thrown when the check fails, e.g.</p>
<pre>//  Checks: n ≥ 0 (assert)</pre>
<p class="cont">or:</p>
<pre>//  Checks: n ≥ 0 (throws Negative)</pre>
<p>This may help when debugging. However, if an exception is thrown to indicate
an error, the client (caller) should <em>not</em> catch that exception. The exception
indicates a problem in the client code that should not just be papered over.
</p>

<p>A third way to deal with partial functions is to make them total, so
that the customer is never wrong:</p>
<pre>
/** Returns: the square root of x. Throws Negative if n is negative.
 */
double sqrt(double x) throws Negative {
    if (x < 0) throw new Negative();
    ...
}
</pre>

<p>
Notice that now the information about the thrown exception is part
of the Returns clause, and appears in the signature, indicating that
this exception is expected behavior in some situations and that
the client had better be ready to handle it when it happens. The client
can call with any arguments it likes, but the price to pay is the client
must write code to handle the exception. The
<em>implementation</em> of <code>sqrt</code> might be exactly
the same as when we used a &ldquo;checks&rdquo; clause. But with the
checks clause, the contract says that the client is in error; but with
exceptions appearing in the returns clause, the client is always
&ldquo;right&rdquo;. Of course, we want to use a checked exception in 
this case so that the compiler reminds the client to handle the exception.
</p>

<!--
<h3>Javadoc and exceptions</h3>
<p>
Javadoc doesn't completely support the clauses we have been describing
thus far, though it has been evolving in that general direction.  If
you want to use Javadoc to generate HTML documentation, you will need
to adapt this documentation strategy accordingly. The key is not that
you need to have explicitly labeled clauses that Javadoc understands,
but that you should know for each thing you write in the comment which
clause it belongs to, and include all the information that should be
found in the clauses that the spec of your code needs.
</p>
-->

<h3>try-with-resources</h3>
<p>
Recent versions of Java have added a useful syntactic sugar that helps make
sure that resources acquired by some code are released at the end.  A
try-with-resources statement looks like an ordinary try-statement
except that it can start with some variable initializers in parentheses. These
variables name the resources used by the statement. They must have a type
which is a subtype of <code>java.lang.AutoCloseable</code>:
</p>
<pre>
interface AutoCloseable {
    void close();
}
</pre>
<p>
The try-with-resources statement ensures that the method <code>close()</code> is
invoked on all of the named resources. For example, if we wanted to read some
data from a file, we might create a <code>FileReader</code> to read from the
file and also a <code>BufferedReader</code> to buffer the input for efficiency:
<pre>
try (Reader fr = new FileReader(filename);
     Reader br = new BufferedReader(fr)) {
    // use br to read input from the file here
} catch (IOException exc) {
    System.err.println("IO exception: " + exc.message());
}
</pre>
<p>
At the end of a try-with-resources, the methods <code>fr.close()</code> and
<code>br.close()</code> will be called, freeing up the corresponding resources
in the operating system, even if an exception (either caught or uncaught) is
thrown. 
</p>
