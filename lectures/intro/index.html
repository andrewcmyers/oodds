<h1>Preface</h1>
<p>
    This book is intended to support a second-semester computer science
    course, one that focuses on material that would be useful to a professional
    software developer. It explores how to use object-oriented programming to
    effectively build complex code, including ideas from software engineering
    “in the small.” It also covers many basic algorithms and data structures,
    using them to develop a stronger foundation for thinking about correctness
    and performance. The reader is expected to have some basic familiarity with
    programming, and to feel comfortable with concepts such as variables,
    functions, arrays, and loops. The book uses Java as the programming
    language, but the reader's prior experience does not need to be with Java.
    At the same time, it is not intended to offer comprehensive coverage
    of Java features.
</p>
<p>
    Topics covered here include object-oriented programming, program
    structure and organization, program reasoning using specifications and
    invariants, recursion, data structures, sorting and graph algorithms,
    asymptotic complexity, and simple algorithmic analysis, design patterns,
    concurrent programming, graphical user interfaces and event-driven programming.
</p>
<p>
    While all of the chapters can be printed out, the book is intended to be
    primarily an online document. Many of the figures include helpful
    animations that will not work when printed out! Further, there are some
    integrated, interactive exercises for the reader.
</p>
<p>
    The material in this book was developed as part of teaching two courses
    at Cornell, CS 2112 and CS 2110. Many people have contributed to the development
    of these courses, including not only the authors but also David Gries,
    Michael Clarkson
</p>
<p>
    This material is a work in progress, and the <a
    href="https://github.com/andrewcmyers/oodds">source code</a> is available
    on GitHub. Future planned improvements include more introductory material
    on programming in Java, and integration of exercises for the reader.
</p>

<h1>Introduction</h1>

<p>
One of the joys of working with computers is that it is relatively easy to
create new things. We can have a creative new idea about an application or
functionality, and produce software that makes that idea real and useful in
a matter of days. The constraints of the real world weigh much less heavily
on software developers than on engineers in other disciplines.
</p>
<p>
But what skills and knowledge do we need in order to make this rapid creation
possible? Of course, we need to understand how to use a programming language
to write code, and this text is written under the assumption that the reader
has done some programming. To build complex software, however, we need more
than just the ability to write code. We need to understand what algorithms and
data structures are available to solve problems efficiently. We need to know
how to break apart a large programming problem into smaller problems that are
less daunting. And for our code to be truly useful, it needs to be written in
a way that makes it easy to maintain and improve over time.
</p>
<p>
To illustrate these challenges of software development, let us suppose that we
are building an application whose users can play some simple games and
puzzles.
</p>
<p>
One classic puzzle that the reader may have seen is the 15-puzzle, introduced
by the famous puzzle designer Sam Lloyd. This puzzle has 15 numbered tiles
within a 4 by 4 grid. There is one empty space, so tiles can be slid into the
empty space to rearrange them. The goal is to arrange the titles in sorted
order starting from the upper left. The puzzle is shown below in a possible
initial unsolved configuration.

<div class=figure>
<canvas id=lloyd_puzzle style="width: 250px; height: 250px">
</canvas>
<audio id=ssh>
  <source src="lectures/intro/ssh.m4a" type="audio/mp4">
</audio>
<audio id=win>
  <source src="lectures/intro/mixkit-ethereal-fairy-win-sound-2019.wav"
          type="audio/wav">
</audio>
<script class=graphics>
    with (new CFigure("lloyd_puzzle")) {
        let border = square().setLineWidth(8).setStrokeStyle("#666")
            .setFillStyle("#aaa")
        let gridSpace = times(border.w(), 0.25)
        align("LR", "TB", border, margin(6))
        const ssh = document.getElementById("ssh"),
              win = document.getElementById("win")
        const positions = []
        let emptyPos = 15
        for (let i = 0; i < 16; i++) {
            positions[i] = point(plus(border.x0(), times(0.5, gridSpace),
                                      times(i % 4, gridSpace)),
                                 plus(border.y0(), times(0.5, gridSpace),
                                      times(Math.floor(i / 4), gridSpace)))
        }
        freeze()
        function tile(n) {
            const result = square().addText("" + n).setLineWidth(4).setFontSize(20)
                .setFillStyle("#db9")
                .setStrokeStyle("#975")
                .setCornerRadius(5)
            result.index = n
            result.control = new TileControl(result)
            return result
        }
        function winningConfig() {
            for (let i = 0; i < 15; i++) {
                if (!tiles[i] || tiles[i].index != i+1) return false
            }
            return true
        }
        class TileControl extends Constrain.Control {
            constructor(tile) {
                super(thisFigure(), tile)
            }
            mousedown(x, y, e) {
                if (this.inBounds(x, y)) {
                    let pos
                    const tile = this.graphic
                    for (let i = 0; i < 16; i++) {
                        if (tiles[i] && tiles[i].index == this.graphic.index) pos = i
                    }
                    function doMove() {
                        const nf = addFrame().setLength(300)
                        tile.constraint.endBefore(nf)
                        const constraints = constraintGroup(
                            equal(tile.x(), smooth(nf, positions[pos].x(),
                                                       positions[emptyPos].x())),
                            equal(tile.y(), smooth(nf, positions[pos].y(),
                                                       positions[emptyPos].y())))
                        tile.constraint = after(nf, constraints)
                        tiles[pos] = undefined
                        tiles[emptyPos] = tile
                        emptyPos = pos
                        advance()
                        if (winningConfig()) {
                            win.play()
                        } else {
                            ssh.play()
                        }
                    }
                    if (pos == emptyPos - 1 && pos % 4 < 3 ||
                        pos == emptyPos + 1 && pos % 4 > 0 ||
                        pos == emptyPos - 4 && pos < 12 ||
                        pos == emptyPos + 4 && pos > 3) { doMove(this) }
                }
            }
        }
        const tiles = new Array(15)
        for (let i = 0; i < 15; i++) {
            tiles[i] = tile(i+1)
            equal(tiles[i].w(), minus(times(0.25, border.w()), 5))
        }
        for (let j = 0; j < 2; j++) {
            const t1 = Math.floor(Math.random() * 15),
                  t2 = Math.floor(Math.random() * 15)
            if (t1 != t2) {
                const tile = tiles[t1]; tiles[t1] = tiles[t2]; tiles[t2] = tile
            } else {
                j-- // only even numbers of swaps are solvable
            }
        }
        let initial = addFrame()
        for (let i = 0; i < 15; i++) {
            const constraints = constraintGroup(
                equal(tiles[i].x(), positions[i].x()),
                equal(tiles[i].y(), (positions[i].y())))

        tiles[i].constraint = after(initial, constraints)
        }
    }
</script>
<p class=caption>The 15-puzzle with most but not all tiles in the right place. Click on tiles to move them.</p>
</div>
