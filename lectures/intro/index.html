<h1>Preface</h1>
<p>
    This book is intended to support a second-semester computer science
    course, one that focuses on material that would be useful to a professional
    software developer. It explores how to use object-oriented programming to
    effectively build complex code, including ideas from software engineering
    “in the small.” It also covers many basic algorithms and data structures,
    using them to develop a stronger foundation for thinking about correctness
    and performance. The reader is expected to have some basic familiarity with
    programming, and to feel comfortable with concepts such as variables,
    functions, arrays, and loops. The book uses Java as the programming
    language, but the reader's prior experience does not need to be with Java.
    At the same time, it is not intended to offer comprehensive coverage
    of Java features.
</p>
<p>
    Topics covered here include object-oriented programming, program
    structure and organization, program reasoning using specifications and
    invariants, recursion, data structures, sorting and graph algorithms,
    asymptotic complexity, and simple algorithmic analysis, design patterns,
    concurrent programming, graphical user interfaces and event-driven programming.
</p>
<p>
    While all of the chapters can be printed out, the book is intended to be
    primarily an online document. Many of the figures include helpful
    animations that will not work when printed out! Further, there are some
    integrated, interactive exercises for the reader.
</p>
<p>
    The material in this book was developed as part of teaching two courses
    at Cornell, CS 2112 and CS 2110. Many people have contributed to the
    development of these courses.
    <!--, including not only the authors but also David Gries, ...!
    Michael Clarkson? Keshav Pingali? ... -->
</p>
<p>
    This material is a work in progress, and the <a
    href="https://github.com/andrewcmyers/oodds">source code</a> is available
    on GitHub. Future planned improvements include more introductory material
    on programming in Java, and integration of exercises for the reader.
</p>

<h1>Introduction</h1>

<p>
One of the joys of working with computers is that it is relatively easy to
create new things. We can have a creative new idea about an application or
functionality, and produce software that makes that idea real and useful in
a matter of days. The constraints of the real world weigh much less heavily
on software developers than on engineers in other disciplines.
</p>
<p>
But what skills and knowledge do we need in order to make this rapid creation
possible? Of course, we need to understand how to use a programming language
to write code, and this text is written under the assumption that the reader
has done some programming. To build complex software, however, we need more
than just the ability to write code. We need to understand what algorithms and
data structures are available to solve problems efficiently. We need to be
expert in using the programming language to express the desired functionality.
We need to know how to break apart a large programming problem into smaller
problems that are less daunting. And for our code to be truly useful, it needs
to be written in a way that makes it easy to maintain and improve over time.
These are the topics covered here.
</p>

<h2>Overview of topics</h2>

<h3>Programming Language Features</h3>
<p>
An important part of being a good software engineer is the ability to
effectively use the features of the programming language being used.  Modern
programming languages have many features that can be used effectively to write
clearer, simpler, and more efficient code, or misused to write complex code
that is hard to maintain. This book is written using Java as the programming
language. Java is one of the most commonly used programming languages.
Of course, Java is far from the only programming language used in practice,
but the lessons we learn from understanding how to use Java will carry
over to other programming lanugages.
</p>
<p>
Like
many popular programming languages, Java is object-oriented, so object-oriented
programming (OOP) is a key topic. However, OOP is actually a harmonious
collection of related ideas that we will carefully explore: data abstraction,
subtyping, and inheritance. Java also supports other important features such as
generics and concurrent programming, and we will see how to use these features
as well.
</p>

<h3>Modular software design</h3>
<p>
Object-oriented languages were designed to support the construction
of complex software systems. A major focus of this text is how to
organize large programs, by breaking them up into separate code
modules that make it easier to design and implement. We will also
explore programming paradigms like concurrent and event-driven programming,
talk about how to design and program user interfaces using graphical
user interface frameworks, and learn about design patterns that can help
us organize code.
</p>

<h3>Algorithms and data structures</h3>

<p>
To write efficient code, a software developer needs to choose how to represent
information in data structures and pick the right algorithms.  Fortunately,
computer scientists have been studying these problems for decades, and have
developed many useful algorithms and data structures. Algorithms can be
tricky to get right, especially when coded for maximum efficiency, so we
will also need to reason carefully about the correctness and
efficiency of algorithms, using techniques like mathematical induction and
asumptotic complexity. We will see how to apply these intellectual
tools to a variety of important data strucutres, including
arrays, lists, stacks, queues, trees, graphs, and hash tables, and to
algorithm that operate on them.
</ul>

</p>
<h2>A Motivating Example</h2>
<p>
To illustrate how the content of this text may be helpful to a software
developer, let us consider an example. Suppose that we want to build a
simple game.
</p>
<p>
One classic puzzle that you may have seen is the 15-puzzle, introduced
by the famous puzzle designer Sam Lloyd. This puzzle has 15 numbered tiles
within a 4 by 4 grid. There is one empty space, so tiles can be slid into the
empty space to rearrange them. The goal is to arrange the titles in sorted
order starting from the upper left. The puzzle is shown below in a possible
initial unsolved configuration.

<div class=figure>
<canvas id=lloyd_puzzle style="width: 250px; height: 250px">
</canvas>
<audio id=ssh>
  <source src="lectures/intro/ssh.m4a" type="audio/mp4">
</audio>
<audio id=win>
  <source src="lectures/intro/mixkit-ethereal-fairy-win-sound-2019.wav"
          type="audio/wav">
</audio>
<script class=graphics>
    with (new CFigure("lloyd_puzzle")) {
        let border = square().setLineWidth(8).setStrokeStyle("#666")
            .setFillStyle("#aaa")
        let gridSpace = times(border.w(), 0.25)
        align("LR", "TB", border, margin(6))
        const ssh = document.getElementById("ssh"),
              win = document.getElementById("win")
        const positions = []
        let emptyPos = 15
        for (let i = 0; i < 16; i++) {
            positions[i] = point(plus(border.x0(), times(0.5, gridSpace),
                                      times(i % 4, gridSpace)),
                                 plus(border.y0(), times(0.5, gridSpace),
                                      times(Math.floor(i / 4), gridSpace)))
        }
        freeze()
        const grd = ctx.createLinearGradient(0, 0, 15, 40)
        grd.addColorStop(0, "#fff"); grd.addColorStop(1, "#db9")
        function tile(n) {
            const result = square().addText("" + n)
                .setLineWidth(4)
                .setFontSize(20)
                .setFillStyle(grd)
                .setStrokeStyle("#975")
                .setCornerRadius(5)
            result.index = n
            result.control = new TileControl(result)
            return result
        }
        function winningConfig() {
            for (let i = 0; i < 15; i++) {
                if (!tiles[i] || tiles[i].index != i+1) return false
            }
            return true
        }
        class TileControl extends Constrain.Control {
            constructor(tile) {
                super(thisFigure(), tile)
            }
            mousedown(x, y, e) {
                if (this.inBounds(x, y)) {
                    let pos
                    const tile = this.graphic
                    for (let i = 0; i < 16; i++) {
                        if (tiles[i] && tiles[i].index == this.graphic.index)
                            pos = i
                    }
                    function doMove() {
                        const nf = addFrame().setLength(300)
                        tile.constraint.endBefore(nf)
                        const constraints = constraintGroup(
                            equal(tile.x(), smooth(nf, positions[pos].x(),
                                                   positions[emptyPos].x())),
                            equal(tile.y(), smooth(nf, positions[pos].y(),
                                                   positions[emptyPos].y())))
                        tile.constraint = after(nf, constraints)
                        tiles[pos] = undefined
                        tiles[emptyPos] = tile
                        emptyPos = pos
                        advance()
                        if (winningConfig()) {
                            win.play()
                        } else {
                            ssh.play()
                        }
                    }
                    if (Math.abs(pos - emptyPos) == 4 ||
                        Math.abs(pos - emptyPos) == 1 && 
                          Math.floor(pos/4) == Math.floor(emptyPos/4))
                      doMove(this)
                }
            }
        }
        const tiles = new Array(15)
        for (let i = 0; i < 15; i++) {
            tiles[i] = tile(i+1)
            equal(tiles[i].w(), minus(times(0.25, border.w()), 5))
        }
        for (let swaps = 0; swaps < 2; ) {
            // Note: only even numbers of swaps are solvable
            const i = Math.floor(Math.random() * 15),
                  j = Math.floor(Math.random() * 15)
            if (i != j) {
                const tile = tiles[i]; tiles[i] = tiles[j]; tiles[j] = tile
                swaps++
            }
        }
        let initial = addFrame()
        for (let i = 0; i < 15; i++) {
            const constraints = constraintGroup(
                equal(tiles[i].x(), positions[i].x()),
                equal(tiles[i].y(), (positions[i].y())))

            tiles[i].constraint = after(initial, constraints)
        }
    }
</script>
<p class=caption>The 15-puzzle with most but not all tiles in the right place.
Click on tiles to move them.</p>
</div>

<p>
Suppose that we want the final version of the app to support hints to the user
about what move to make next, and even automatic solving capabilitiy.
</p>

<p>
The problem of designing this application raises many questions. In
an object-oriented languages, we probably want to represent the state
of the puzzle as an object. What operations should puzzle objects have?
What data is stored inside puzzle objects to represent the state
of the puzzle? What is the right user interface for the application,
one that presents the right information to the user and gives them the
ability to interact efficiently and enjoyably with it?
</p>

<p>
The application also raises questions about data structures and algorithms.
Efficient algorithms are especially important if we want the

<h2>Puzzles as graphs</h2>
