<h1>Preface</h1>
<p>
    This book is intended to support a second-semester computer science
    course, one that focuses on material that would be useful to a professional
    software developer. It explores how to use object-oriented programming to
    effectively build complex code, including ideas from software engineering
    “in the small.” It also covers many basic algorithms and data structures,
    using them to develop a stronger foundation for thinking about correctness
    and performance. The reader is expected to have some basic familiarity with
    programming, and to feel comfortable with concepts such as variables,
    functions, arrays, and loops. The book uses Java as the programming
    language, but the reader's prior experience does not need to be with Java.
    At the same time, it is not intended to offer comprehensive coverage
    of Java features.
</p>
<p>
    Topics covered here include object-oriented programming, program
    structure and organization, program reasoning using specifications and
    invariants, recursion, data structures, sorting and graph algorithms,
    asymptotic complexity, and simple algorithmic analysis, design patterns,
    concurrent programming, graphical user interfaces and event-driven programming.
</p>
<p>
    While all of the chapters can be printed out, the book is intended to be
    primarily an online document. Many of the figures include helpful
    animations that will not work when printed out! Further, there are some
    integrated, interactive exercises for the reader.
</p>
<p>
    The material in this book was developed as part of teaching two courses
    at Cornell, CS 2112 and CS 2110. Many people have contributed to the
    development of these courses.
    <!--, including not only the authors but also David Gries, ...!
    Michael Clarkson? Keshav Pingali? ... -->
</p>
<p>
    This material is a work in progress, and the <a
    href="https://github.com/andrewcmyers/oodds">source code</a> is available
    on GitHub. Future planned improvements include more introductory material
    on programming in Java, and integration of exercises for the reader.
</p>

<h1>Introduction</h1>

<p>
One of the joys of working with computers is that it is relatively easy to
create new things. We can have a creative new idea about an application or
functionality, and produce software that makes that idea real and useful in
a matter of days. The constraints of the real world weigh much less heavily
on software developers than on engineers in other disciplines.
</p>
<p>
But what skills and knowledge do we need in order to make this rapid creation
possible? Of course, we need to understand how to use a programming language
to write code, and this text is written under the assumption that the reader
has done some programming. To build complex software, however, we need more
than just the ability to write code. We need to understand what algorithms and
data structures are available to solve problems efficiently. We need to be
expert in using the programming language to express the desired functionality.
We need to know how to break apart a large programming problem into smaller
problems that are less daunting. And for our code to be truly useful, it needs
to be written in a way that makes it easy to maintain and improve over time.
These are the topics covered here.
</p>

<h2>Overview of topics</h2>

<h3>Programming Language Features</h3>
<p>
An important part of being a good software engineer is the ability to
effectively use the features of the programming language being used.  Modern
programming languages have many features that can be used effectively to write
clearer, simpler, and more efficient code, or misused to write complex code
that is hard to maintain. This book is written using Java as the programming
language. Java is one of the most commonly used programming languages.
Of course, Java is far from the only programming language used in practice,
but the lessons we learn from understanding how to use Java will carry
over to other programming lanugages.
</p>
<p>
Like
many popular programming languages, Java is object-oriented, so object-oriented
programming (OOP) is a key topic. However, OOP is actually a harmonious
collection of related ideas that we will carefully explore: data abstraction,
subtyping, and inheritance. Java also supports other important features such as
generics and concurrent programming, and we will see how to use these features
as well.
</p>

<h3>Modular software design</h3>
<p>
Object-oriented languages were designed to support the construction
of complex software systems. A major focus of this text is how to
organize large programs, by breaking them up into separate code
modules that make it easier to design and implement. We will also
explore programming paradigms like concurrent and event-driven programming,
talk about how to design and program user interfaces using graphical
user interface frameworks, and learn about design patterns that can help
us organize code.
</p>

<h3>Algorithms and data structures</h3>

<p>
To write efficient code, a software developer needs to choose how to represent
information in data structures and pick the right algorithms.  Fortunately,
computer scientists have been studying these problems for decades, and have
developed many useful algorithms and data structures. Algorithms can be
tricky to get right, especially when coded for maximum efficiency, so we
will also need to reason carefully about the correctness and
efficiency of algorithms, using techniques like mathematical induction and
asumptotic complexity. We will see how to apply these intellectual
tools to a variety of important data strucutres, including
arrays, lists, stacks, queues, trees, graphs, and hash tables, and to
algorithm that operate on them.
</ul>

</p>
<h2>A Motivating Example</h2>
<p>
To illustrate how the content of this text may be helpful to a software
developer, let us consider an example. Suppose that we want to build a
simple game.
</p>
<p>
One classic puzzle that you may have seen is the 15-puzzle, introduced
by the famous puzzle designer Sam Lloyd. This puzzle has 15 numbered tiles
within a 4 by 4 grid. There is one empty space, so tiles can be slid into the
empty space to rearrange them. The goal is to arrange the titles in sorted
order starting from the upper left. The puzzle is shown below in a possible
initial unsolved configuration.

<div class=figure>
<canvas id=lloyd_puzzle style="width: 250px; height: 250px">
</canvas>
<audio id=ssh>
  <source src="lectures/intro/ssh.m4a" type="audio/mp4">
</audio>
<audio id=win>
  <source src="lectures/intro/mixkit-ethereal-fairy-win-sound-2019.wav"
          type="audio/wav">
</audio>
<script class=graphics>
    class TileControl extends Constrain.Control {
        constructor(puzzle, tile) {
            super(puzzle.figure, tile)
            this.puzzle = puzzle
        }
        mousedown(x, y, e) {
            if (this.inBounds(x, y)) {
                let pos
                const control = this,
                        puzzle = this.puzzle,
                        tile = this.graphic,
                        emptyPos = puzzle.emptyPos,
                        tiles = puzzle.tiles,
                        positions = puzzle.positions,
                        f = puzzle.figure
                for (let i = 0; i < 16; i++) {
                    if (puzzle.tiles[i] &&
                        puzzle.tiles[i].index == this.graphic.index)
                        pos = i
                }
                const diff = Math.abs(pos - emptyPos), s = puzzle.size
                if (diff == s ||
                    diff == 1 && 
                        Math.floor(pos/s) == Math.floor(emptyPos/s))
                {
                    const nf = f.addFrame().setLength(300)
                    tile.constraint.endBefore(nf)
                    const constraints = f.constraintGroup(
                        f.equal(tile.x(), f.smooth(nf, positions[pos].x(),
                                                positions[emptyPos].x())),
                        f.equal(tile.y(), f.smooth(nf, positions[pos].y(),
                                                positions[emptyPos].y())))
                    tile.constraint = f.after(nf, constraints)
                    tiles[pos] = undefined
                    tiles[emptyPos] = tile
                    puzzle.emptyPos = pos
                    f.advance()
                    if (puzzle.winningConfig()) win.play()
                    else ssh.play()
                }
            }
        }
    }
    class LloydPuzzle extends Constrain.LayoutObject {
        constructor(figure, labels, startFrame, solvable) {
            super(figure)
            this.figure = figure
            this.solvable = solvable
            this.size = Math.ceil(Math.sqrt(labels.length))
            // console.log("size = " + this.size)
            const ssh = document.getElementById("ssh"),
                win = document.getElementById("win"),
                grd = figure.ctx.createLinearGradient(0, 0, 15, 40)
            grd.addColorStop(0, "#fff"); grd.addColorStop(1, "#db9")

            const tiles = this.tiles = new Array(16),
                    border = this.border =
                figure.square().setLineWidth(8).setStrokeStyle("#666")
                    .setFillStyle("#aaa"),
                    positions = this.setupPositions()
            for (let i = 0; i < this.size * this.size; i++) {
                if (labels[i] !== undefined) {
                    const tile = tiles[i] = this.makeTile(labels[i], grd)
                    figure.equal(tile.w(), figure.minus(figure.times(1/this.size, border.w()), 5))
                    const constraints = figure.constraintGroup(
                            figure.equal(tile.x(), positions[i].x()),
                            figure.equal(tile.y(), positions[i].y()))
                    tiles[i].constraint = solvable
                        ? figure.after(startFrame, constraints)
                        : constraints
                } else {
                    this.emptyPos = i
                }
            }
        }
        makeTile(n, fill) {
            const f = this.figure
            const result = f.square().addText("" + n)
                .setLineWidth(3)
                .setFillStyle(fill)
                .setStrokeStyle("#975")
                .setCornerRadius(5)
            // result.setFontSize(f.times(result.w(), 0.2))
            result.setFontSize(18)
            result.index = n
            if (this.solvable)
                result.control = new TileControl(this, result)
            return result
        }
        setupPositions() {
            const positions = new Array(this.size*this.size),
                  border = this.border,
                  f = this.figure,
                  gridSpace = f.times(border.w(), 1/this.size)
            for (let i = 0; i < this.size*this.size; i++) {
                const x = f.plus(border.x0(), f.times(0.5, gridSpace),
                             f.times(i % this.size, gridSpace)),
                      y = f.plus(border.y0(), f.times(0.5, gridSpace),
                             f.times(Math.floor(i/this.size), gridSpace))
                positions[i] = f.point(x, y)
            }
            this.positions = positions
            return positions
        }
        winningConfig() {
            for (let i = 0; i < this.size*this.size-1; i++) {
                if (!this.tiles[i] || this.tiles[i].index != i+1)
                    return false
            }
            return true
        }
        x() { return this.border.x() }
        y() { return this.border.y() }
        w() { return this.border.w() }
        h() { return this.border.h() }
    }
    window.LloydPuzzle = LloydPuzzle
    with (new CFigure("lloyd_puzzle")) {
        let first = addFrame()
        const size = 15
        const init = new Array(size)
        for (let i = 0; i < size; i++) init[i] = i+1
        for (let swaps = 0; swaps < 2; ) {
            // Note: only even numbers of swaps are solvable
            const i = Math.floor(Math.random() * size),
                  j = Math.floor(Math.random() * size)
            if (i != j) {
                const tile = init[i]; init[i] = init[j]; init[j] = tile
                swaps++
            }
        }
        const puzzle = new LloydPuzzle(thisFigure(), init, first, true)
        align("LR", "TB", puzzle, margin(6))
    }
</script>
<p class=caption>The 15-puzzle with most but not all tiles in the right place.
Click on tiles to move them.</p>
</div>

<p>
Suppose that we want the final version of the app to support hints to the user
about what move to make next, and even some automatic solving capability.
</p>

<p>
The problem of designing this application raises many questions. In
an object-oriented languages, we probably want to represent the state
of the puzzle as an object. What operations should puzzle objects have?
What data is stored inside puzzle objects to represent the state
of the puzzle? What is the right user interface for the application,
one that presents the right information to the user and gives them the
ability to interact efficiently and enjoyably with it?
</p>

<p>
The application also raises questions about data structures and algorithms.
Efficient algorithms are especially important to support features like
suggestions and automatic solving, because the software needs to be able
to explore many possible sequences of moves.

<h2>Puzzles as graphs</h2>

<p>
Developing algorithms for the 15-puzzle is made much easier if we
recognize that it is an example of an important computer science
abstraction: a <b>graph</b>.
</p>
<p>
Imagine we could draw all of the possible states of the 15-puzzle
on a sheet of paper. We'd need a truly huge sheet of paper because
there are so many possible states of the puzzle. From each of these
possible states there are 2, 3, or 4 possible moves that can be
made, depending on the position of the empty space into which tiles
can be slid.
</p>
<p>
For example, consider the puzzle configuration shown at the center
of the following diagram. In this state, there are four possible
moves, as indicated by the four outgoing arrows labeled N, S, E, and W for
the points of the compass. Making one of these moves results in the
state that the arrow leads to, from which additional moves can be
made. For example, after making an N move, you can make an S move
to get back to the original state.
</p>

<div class=figure>
<canvas id=puzzle_moves style="height: 600px; width: 600px"></canvas>
<p class=caption>Some puzzle states and possible moves between them</p>
<script class=graphics>
    with (new CFigure("puzzle_moves")) {
        const frame = addFrame()
        function puzzle(init) {
          const result = new LloydPuzzle(thisFigure(), init, frame, false)
          equal(result.w(), 150)
          return result
        }
        const center = puzzle([6,  1,  2, 4,
                               15, 10, undefined, 7,
                               9,  11, 3, 8,
                               13, 14, 5, 12])
        const east = puzzle([6,  1,  2, 4,
                              15, undefined, 10, 7,
                              9,  11, 3, 8,
                              13, 14, 5, 12])
        const west = puzzle([6,  1,  2, 4,
                              15, 10, 7, undefined,
                              9,  11, 3, 8,
                              13, 14, 5, 12])
        const north = puzzle([6,  1,  2, 4,
                              15, 10, 3, 7,
                              9,  11, undefined, 8,
                              13, 14, 5, 12])
        const south = puzzle([6,  1,  undefined, 4,
                              15, 10, 2, 7,
                              9,  11, 3, 8,
                              13, 14, 5, 12])

        align("abut", "TB", west, hspace(50), center, hspace(50), east)
        align("LR", "abut", north, vspace(50), center, vspace(50), south)
        align("center", "center", center, margin())
        setLineWidth(2)
        freeze()
        const ne = puzzle([6,  1,  2, 4,
                           15, 10, 3, 7,
                           9,  undefined, 11, 8,
                           13, 14, 5, 12])
        const nw = puzzle([6,  1,  2, 4,
                           15, 10, 3, 7,
                           9,  11, 8, undefined,
                           13, 14, 5, 12])
        align("L", "none", west, margin(6))
        align("none", "T", north, margin(6))
        align("none", "B", south, margin(6))
        align("LR", "none", ne, east)
        align("LR", "none", nw, west)
        align("none", "TB", ne, north)
        align("none", "TB", nw, north)

        freeze()
        setTextStyle("black")
        const se = puzzle([6,  undefined, 1, 4,
                           15, 10, 2, 7,
                           9,  11, 3, 8,
                           13, 14, 5, 12])
        const sw = puzzle([6,  1,  4, undefined,
                           15, 10, 2, 7,
                           9,  11, 3, 8,
                           13, 14, 5, 12])
        align("none", "TB", sw, south, se)
        align("LR", "none", west, sw)
        align("LR", "none", east, se)
        setTextStyle("blue")
        setStrokeStyle("blue")
        arrow(center, east).addLabel("E")
        arrow(center, west).addLabel("W")
        arrow(center, north).addLabel("N")
        arrow(center, south).addLabel("S")
        arrow(north, ne).addLabel("E")
        arrow(north, nw).addLabel("W")
        arrow(south, se).addLabel("E")
        arrow(south, sw).addLabel("W")

        const as = 12
        arrow(south.uc().toLeft(as), center.lc().toLeft(as)).addLabel("N")
        arrow(north.lc().toRight(as), center.uc().toRight(as)).addLabel("S")
        arrow(east.cl().toBottom(as), center.cr().toBottom(as)).addLabel("W")
        arrow(west.cr().toTop(as), center.cl().toTop(as)).addLabel("E")
        arrow(ne.cl().toBottom(as), north.cr().toBottom(as)).addLabel("W")
        arrow(nw.cr().toTop(as), north.cl().toTop(as)).addLabel("E")
        arrow(sw.cr().toTop(as), south.cl().toTop(as)).addLabel("E")
        arrow(se.cl().toBottom(as), south.cr().toBottom(as)).addLabel("W")
    }
</script>
</div>

<p>
The problem of solving the 15-puzzle is the problem of finding a path
through this diagram until the solved state is reached. Fortunately,
this is a problem that computer scientists have though about a great deal,
though not specifically in the context of the 15-puzzle. Instead, a
computer scientist might view this problem as the more general problem
for finding a path through a <b>graph</b>. A graph is a mathematical
structure comprising a set of <b>vertices</b> (or <b>nodes</b>), connected
by a set of <b>edges</b>. To view the diagram above as a graph, we
consider the puzzle states to be the vertices of the graph and the
moves between the states to be the edges of the graph.
</p>
<p>
The value of seeing this problem as a graph is that graphs have been
studied for centuries by mathematicians and computer scientists, and
there is a huge toolbox of problem-solving techniques that we can
draw upon.
</p>

